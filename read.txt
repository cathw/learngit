this is a txt
show the test of git
1、初始化一个Git仓库
git init
(切换到相应项目目录，如 cd /www/test,然后输入git init)

2、添加文件到git仓库
① git add [file]  可反复多次使用，添加多个文件，如git add test1.txt （回车） git add test2.txt
② git commit -m "explain"    -m后面输入的是本次提交的说明，可以输入任意内容

3、查看工作区状态，是否有添加或修改文件
git status

4、查看修改内容
git diff

5、如果文件修改完，要重新提交，步骤同2操作，或者使用 git commit -am "add and commit" 一次性添加并提交

6、查看提交版本历史
git log 
git log --pretty=oneline  以一行形式显示日志
查看命令历史
git reflog

7、版本回退
git reset --hard commit_id   commit_id表示版本号  commit_id为head表示当前版本，为head^表示回退到上一个版本，为head~100表示回退到往上100个版本
如果不小心回退到上一个版本，之后又想回到当前版本，可以通过git reflog查看执行过的命令，找到当前版本号，然后进行git reset --hard 当前版本号   即可回到当前版本

8、分支概念
工作区  -- 暂存区stage ---分支master
使用git add 提交后，被提交的内容就进入到暂存区（版本a），此时还未进行git commit提交到分支
这个时候，再对提交的内容进行修改（版本b），但未进行git add 而是进行git commit命令时，只会提交暂存区的内容（即版本a）到分支，而工作区的内容（版本b）不会被提交到分支，因为此时它的修改并没有进入到暂存区

9、撤销修改
git checkout --read.txt  把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
总之，就是让这个文件回到最近一次git commit或git add时的状态。

举例：
（1）9:10  添加a
此时git checkout --read.txt    添加a在工作区会被删除，暂存区无‘添加a’
（2）9:15  添加b 且 进行git add read.txt
9:18  添加c
此时git checkout --read.txt    添加b在暂存区不会被删除，‘添加c’在工作区会被删除，
如果要删除暂存区内容‘添加b’，则进行命令：git reset head -- read.txt
然后 git checkout --read.txt  之后git status查看下已经没有可commit的文件了，且工作区的read.txt，内容‘添加b’也已经被撤销了

小结撤销修改：
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

10、删除文件
git rm -- 文件名

如果delete.txt只是在本地工作区，未提交到存储区和分支，则rm delete.txt操作会将无法恢复文件
如果delete.txt 提交到存储区和分支了，则rm delete.txt后，只是删除工作区文件，此时版本库还有该文件，如果要彻底删除，则使用git rm delete.txt，并git commit -m 'remove delete.txt';如果是误操作，则使用git checkout -- delete.txt进行恢复，且只能恢复文件到最新版本

11、连接远程仓库
ssh-keygen -t rsa -C "youremail@example.com"   #创建ssh key
ssh -T git@github.com  #验证是否配置成功
复制id_rsa.pub内容，Add SSH Key到github
在github创建git仓库（Create a new repository）
git remote add origin git@server-name:path/repo-name.git #关联到远程库
git push -u origin master  #第一次推送master分支的所有内容
git push origin master  #推送最新修改

12、从远程库克隆
git clone git@server-name:path/repo-name.git

13、创建并切换分支
git checkout -b dev
相当于以下两条命令
git branch dev   #增加分支
git checkout dev  #切换到dev分支

14、查看当前分支
git branch   #当前分支前面会标有一个*号

15、合并某分支到当前分支
git merge <branch_name>

16、删除分支
git branch -d <branch_name> 
git branch -D <branch_name>强行删除

17、解决冲突
当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
Git用<<<<<<<，版本1=======，版本2>>>>>>>标记出不同分支的内容
用git log --graph命令可以看到分支合并图
git log --graph --pretty=oneline --abbrev-commit

18、分支管理策略
通常，合并分支时，如果可能，git会用Fast forward模式，但在这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。
git merge --no-ff -m 'merge with no-ff' dev  #参数--no-ff 表示禁用Fast forward,因为本次合并要创建一个新的commit，所以加上参数-m

同样可以使用git log --graph --pretty=oneline --abbrev-commit查看分支历史

19、bug分支
通常解决bug会使用git stash命令暂存当前写到一半的代码，
切换到某个分支dev上，新建一个分支来专门修复bug，
修复完再合并到分支dev（git merge --no-ff -m 'fix bug001' dev），
并删除bug分支（git branch -d bug001），
之后切换到先前写到一半的代码分支dev2，恢复代码：git stash pop（修复的同时并删除stash内容），
还可以使用git stash apply恢复，再用git stash drop删除stash内容
git stash list查看状态

20、查看远程库信息
git remote
git remote -v   #查看远程库详细信息
git push origin <branch_name>    #推送branch_name分支上所有本地提交内容到远程库

git branch --set-upstream dev origin/dev   #指定本地dev分支与远程origin/dev分支的链接
git pull    #拉取远程最新的提交内容
如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name进行链接


21、创建标签
git tag <tag_name>  #创建标签,默认HEAD
git tag    #查看所有标签
git tag <tag_name> <commit_id>   #创建指定某个版本的标签
git show <tag_name>    #查看标签信息
git tag -a  <tag_name> -m 'explain' <commit_id>  #创建带有说明的标签并指定某个版本 -a指定标签名，-m指定说明文字
git tag -s <tag_name> -m "blablabla..."   #可以用PGP签名标签,但必须先安装gpg（GnuPG），否则会报错


21、删除标签
git tag -d <tag_name>  

22、推广标签到远程
git push origin <tag_name>
git push origin --tag   #推送本地全部未推送过的标签

23、删除远程标签
先git push -d <tag_name>  再git push origin :refs/tags/<tag_name>